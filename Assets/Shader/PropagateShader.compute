#pragma kernel CSMain

// Grid properties, set from C#:
uint Width;
uint Height;
uint Depth;

// Input and output buffers

StructuredBuffer<int> Tiles;

//Store
StructuredBuffer<double> StoreSize;
StructuredBuffer<double> StoreRate;
RWStructuredBuffer<double> Store;

//Propagation
StructuredBuffer<double> Input;
StructuredBuffer<double> Liquidity;
RWStructuredBuffer<double> Output;

//Loss
StructuredBuffer<double> Loss;

//Production
StructuredBuffer<double> Production;
StructuredBuffer<double> Consumption;
StructuredBuffer<int> Cooldown;
RWStructuredBuffer<int> Timer;

uint tileIndex(uint x, uint y)
{
    return y * Width + x;
}

uint layeredTileIndex(uint x, uint y, uint z)
{
    return z * Width * Height + y * Width + x;
}

uint tileTypeIndex(uint x, uint y)
{
    return Tiles[tileIndex(x, y)];
}

uint layeredTileTypeIndex(uint x, uint y, uint z)
{
    return z + Depth * Tiles[tileIndex(x, y)];
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const uint x = id.x;
    const uint y = id.y;
    const uint z = id.z;
    const uint index = layeredTileTypeIndex(x, y, z);
    const uint layeredTileType = layeredTileTypeIndex(x, y, z);

    double acc = 0;
    double flow = 0;

    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            if (abs(dx) + abs(dy) != 1) continue; // Skip non-adjacent cells

            int nx = x + dx;
            int ny = y + dy;

            const double currentLiquidity = Liquidity[layeredTileType];
            if (nx >= 0 && nx < Width && ny >= 0 && ny < Height)
            {
                const uint neighborIndex = layeredTileIndex(nx, ny, z);
                const double neighborLiquidity = Liquidity[layeredTileTypeIndex(nx, ny, z)];
                acc += currentLiquidity * Input[neighborIndex] * 0.25;
                flow += neighborLiquidity * 0.25;
            }
            else
            {
                acc += Input[index] * currentLiquidity * 0.25;
                flow += currentLiquidity * 0.25;
            }
        }
    }

    acc += Input[index] * (1 - flow);
    // Store
    const double toStore = min(min(StoreRate[layeredTileType], StoreSize[layeredTileType] - Store[index]), acc);
    Store[index] += toStore;
    acc -= toStore;

    //Production + Consumption
    if (Timer[tileIndex(x, y)] % Cooldown[tileTypeIndex(x, y)] == 0 && z == 0)
    {
        bool productionReady = true;
        for (int layer = 0; layer < Depth; layer++)
        {
            if (Store[layeredTileIndex(x, y, layer)] < Consumption[layeredTileTypeIndex(x, y, layer)])
            {
                productionReady = false;
                break;
            }
        }

        if (productionReady)
        {
            for (int layer = 0; layer < Depth; layer++)
            {
                Store[layeredTileIndex(x, y, layer)] -= Consumption[layeredTileTypeIndex(x, y, layer)];
                Store[layeredTileIndex(x, y, layer)] += Production[layeredTileTypeIndex(x, y, layer)];
            }
        }
    }

    // Subtract loss
    acc -= Loss[layeredTileType];

    Output[index] = max(acc, 0);
    Timer[y * Width + x]++;
}
