#pragma kernel CSMain

// Grid properties, set from C#:
int Width;
int Height;
int Depth;

// Input and output buffers

StructuredBuffer<int> Tiles;

//Store
StructuredBuffer<double> StoreSize;
StructuredBuffer<double> StoreRate;
RWStructuredBuffer<double> Store;

//Propagation
StructuredBuffer<double> Input;
StructuredBuffer<double> Liquidity;
RWStructuredBuffer<double> Output;

//Loss
StructuredBuffer<double> Loss;

//Production
StructuredBuffer<double> Production;
StructuredBuffer<double> Consumption;
StructuredBuffer<int> Cooldown;
RWStructuredBuffer<int> Timer;

int tile_index(const int x, const int y)
{
    return y * Width + x;
}

int layered_tile_index(const int x, const int y, const int z)
{
    return z * Width * Height + y * Width + x;
}

int tile_type_index(const int x, const int y)
{
    return Tiles[tile_index(x, y)];
}

int layered_tile_type_index(const int x, const int y, const int z)
{
    return z + Depth * Tiles[tile_index(x, y)];
}

double do_propagate(const int x, const int y, const int z, const int index, double acc)
{
    double flow = 0;
    const int layeredTileType = layered_tile_type_index(x, y, z);

    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            if (abs(dx) + abs(dy) != 1) continue; // Skip non-adjacent cells

            const int nx = x + dx;
            const int ny = y + dy;

            const double currentLiquidity = Liquidity[layeredTileType];
            if (nx >= 0 && nx < Width && ny >= 0 && ny < Height)
            {
                const int neighborIndex = layered_tile_index(nx, ny, z);
                const double neighborLiquidity = Liquidity[layered_tile_type_index(nx, ny, z)];
                acc += currentLiquidity * Input[neighborIndex] * 0.25;
                flow += neighborLiquidity * 0.25;
            }
            else
            {
                acc += Input[index] * currentLiquidity * 0.25;
                flow += currentLiquidity * 0.25;
            }
        }
    }
    return acc + Input[index] * (1 - flow);
}

double do_store(const int index, const int layeredTileType, double acc)
{
    const double toStore = min(min(StoreRate[layeredTileType], StoreSize[layeredTileType] - Store[index]), acc);
    Store[index] += toStore;
    return acc - toStore;
}

void do_production(const int x, const int y, const int z)
{
    if (Timer[tile_index(x, y)] % Cooldown[tile_type_index(x, y)] != 0 || z != 0)
    {
        return;
    }

    for (int layer = 0; layer < Depth; layer++)
    {
        if (Store[layered_tile_index(x, y, layer)] < Consumption[layered_tile_type_index(x, y, layer)])
        {
            return;
        }
    }

    for (int layer = 0; layer < Depth; layer++)
    {
        Store[layered_tile_index(x, y, layer)] -= Consumption[layered_tile_type_index(x, y, layer)];
        Store[layered_tile_index(x, y, layer)] += Production[layered_tile_type_index(x, y, layer)];
    }
}

double do_loss(const int layeredTileType, double acc)
{
    return acc - Loss[layeredTileType];
}

[numthreads(8, 8, 1)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    const int x = id.x;
    const int y = id.y;
    const int z = id.z;
    const int index = layered_tile_index(x, y, z);
    const int layeredTileType = layered_tile_type_index(x, y, z);

    double acc = 0;
    acc = do_propagate(x, y, z, index, acc);
    acc = do_store(index, layeredTileType, acc);
    do_production(x, y, z);
    acc = do_loss(layeredTileType, acc);

    Output[index] = max(acc, 0);
    Timer[tile_index(x, y)]++;
}
