#pragma kernel CSMain

// Grid properties, set from C#:
uint Width;
uint Height;

// Input and output buffers
StructuredBuffer<double> Input;
StructuredBuffer<double> Liquidity;
RWStructuredBuffer<double> Output;

uint CountNeighbors(uint x, uint y)
{
    uint result = 0;
    if (x > 0) result++;
    if (x < Width - 1) result++;
    if (y > 0) result++;
    if (y < Height - 1) result++;
    return result;
}

double CalculateContribution(uint index, uint neighbor)
{
    return Liquidity[index] * Input[neighbor] * 0.25;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const uint x = id.x;
    const uint y = id.y;
    const uint index = y * Width + x;

    double acc = 0;
    double flow = 0;

    // Add contributions from neighbors or retain mass at borders
    for (int dx = -1; dx <= 1; dx++)
    {
        for (int dy = -1; dy <= 1; dy++)
        {
            if (abs(dx) + abs(dy) != 1) continue; // Skip non-adjacent cells

            int nx = x + dx;
            int ny = y + dy;

            if (nx >= 0 && nx < Width && ny >= 0 && ny < Height)
            {
                const uint neighborIndex = ny * Width + nx;
                acc += CalculateContribution(index, neighborIndex);
                flow += Liquidity[neighborIndex] * 0.25;
            }
            else
            {
                acc += Input[index] * Liquidity[index] * 0.25;
                flow += Liquidity[index] * 0.25;
            }
        }
    }

    // Add self-retention
    acc += Input[index] * (1 - flow);

    Output[index] = acc;
}
